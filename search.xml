<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello Wds~</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>重名就会被覆盖？那JavaScript中是如何实现重载的呢？</title>
      <link href="/%E9%87%8D%E5%90%8D%E5%B0%B1%E4%BC%9A%E8%A2%AB%E8%A6%86%E7%9B%96%EF%BC%9F%E9%82%A3JavaScript%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%91%A2%EF%BC%9F/"/>
      <url>/%E9%87%8D%E5%90%8D%E5%B0%B1%E4%BC%9A%E8%A2%AB%E8%A6%86%E7%9B%96%EF%BC%9F%E9%82%A3JavaScript%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%87%8D%E8%BD%BD%E7%9A%84%E5%91%A2%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="http://p7jj1bbaq.bkt.clouddn.com/1648d606a47dc799.png" alt="--"></p><blockquote><p>大家都知道，所谓重载，就是一组相同的函数名，有不同个数的参数，在使用时调用一个函数名，传入不同参数，根据你的参数个数，来决定使用不同的函数！重载这个在JAVA这些经典的编程语言里面都很好用，可以说调用同一个方法名用不同的参数就可以为所欲为了。</p></blockquote><p>但是我们知道JavaScript中是没有重载的（为什么没重载？不是JAVA的特性JavaScript也会有的吗？），因为后面定义的函数会覆盖前面的同名函数，但是重载那么好用，我们想在JavaScript实现函数重载该怎么办呢？</p><p>实现javascript重载一般有两种方式：</p><h2 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h2><p>这种方法比较简单，给一个思路，大家肯定都能理解，就是函数内部用switch语句，根据传入参数的个数调用不同的case语句，从而功能上达到重载的效果。这种方法简单粗暴。但是对于一个正在学习js的人来说，这种方法未免太敷衍了。（那么没技术含量，怎么能让我变成前端开发大神呢？）</p><p>下面重点介绍一下第二种，老实说我第一次看的时候很吃力，看了一个小时才捋清楚，因为有的知识点虽然看过了但是不熟悉。（干货很足，别看走神）</p><h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><p>我们这个例子，是如果你不传入参数，就会输出所有的人，输入firstname，就会输出匹配的人，如果输入全名的人，也会输出匹配的人。如果用重载的话，用户体验确实会很好（这个例子是我以前学习时从网上扒下来的，很经典，具有代表性，但是他们都没有写实现过程，所以今天我来给大家说讲一下）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二种实现重载</span></span><br><span class="line">functuin method(obj, name, fnc)&#123;</span><br><span class="line">  <span class="keyword">var</span> old = obj[name];</span><br><span class="line">  <span class="built_in">console</span>.log(old, <span class="keyword">instanceof</span> <span class="built_in">Function</span>);</span><br><span class="line"></span><br><span class="line">  obj[name] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length + <span class="string">" "</span> + fnc.length);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length === fnc.length)&#123;</span><br><span class="line">      <span class="keyword">return</span> fnc.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(typeog old === <span class="string">"function"</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> old.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶一个用于查找和输出的数组</span></span><br><span class="line"><span class="keyword">var</span> people = &#123;</span><br><span class="line">  values : [<span class="string">"Zhang san"</span>,<span class="string">"Li si"</span>,<span class="string">"Wang wu"</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载实现无参数查找方法，结果输出所有人</span></span><br><span class="line">method(people, <span class="string">"find"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"无参数"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.values;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载一个参数的查找方法，输入firstname参数，找到匹配该firstname的人</span></span><br><span class="line">method(people,<span class="string">"find"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">firstname</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"一个参数"</span>);</span><br><span class="line">  <span class="keyword">var</span> ret = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="keyword">this</span>.values.length ; i ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.values[i].indexOf(firstname) === <span class="number">0</span>)&#123;</span><br><span class="line">      ret.push(<span class="keyword">this</span>.values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载两个参数的查找方法，输入全名，找到对应的人</span></span><br><span class="line">method(people, <span class="string">"find"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">firstname, lastname</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"两个参数"</span>);</span><br><span class="line">  <span class="keyword">var</span> ret = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(val i = <span class="number">0</span> ; i &lt; <span class="keyword">this</span>.values.length ; i ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.values[i] == firstname + <span class="string">" "</span> + lastname)&#123;</span><br><span class="line">      ret.push(<span class="keyword">this</span>.values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(people.find());</span><br><span class="line"><span class="built_in">console</span>.log(people.find(<span class="string">"Zhang"</span>));</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这段代码第一眼看的时候肯定是懵的，再看一次好像有点思路，再看就又懵了。其实呢，这种方法巧妙的运用了JavaScript的闭包原理（重点），既然js后面的函数会覆盖前面的同名函数，我就强行让所有的函数都留在内存里，等我需要的时候再去找它。有了这个想法，是不是就想到了闭包，函数外访问函数内的变量，从而使函数留在内存中不被删除。这就是闭包的核心作用。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>从上面代码来看，最重要的就是<code>method</code>方法的定义：这个方法中最重要的一点就是这个<code>old</code>，在这里<code>old</code>的设置很巧妙。他的作用相当于一个指针，指向上一次调用的<code>method</code>函数，具体从代码中来说。先看js中的解析顺序来看：</p><ol><li>解析<code>method</code>（先忽略里面的东西）</li><li>执行<code>method(people, &quot;find&quot;, function())</code>的时候，他会去执行上面定义的方法，然后此时的<code>old</code>值为空。因为你还没有定义这个函数，所以它此时是<code>undefined</code>然后继续执行，这时候我们才定义<code>object[name] = function()</code>。这时候js解析的时候发现返回了<code>fnc</code>函数，更重要的是<code>fnc</code>函数里面还调用了<code>method</code>里面的变量，这样就构成了闭包。<br>因为<code>fnc</code>函数的实现是在调用的时候才会去实现，所以js就想，这我执行完也不能删除，要不外面的用什么。就先留着吧（此处用<code>apply</code>函数改变了<code>fnc</code>函数的<code>this</code>指向）</li><li>好了第一次的<code>method</code>的使用结束了，开始第二句，<code>method(peole, &quot;find&quot;, function(firstname))</code>然后在这次使用的时候，又会去执行一次<code>old = obj[name]</code>。此事的<code>old</code>是什么，是函数了，因为上一次已经定义过了，且没有被删除，那么这次的<code>old</code>实际上是上次定义的方法，他起的作用好像一个指针，指向了上一次定义的<code>obj[name]</code>。然后再往下看，又是闭包，还得继续留着。</li><li>第三局的<code>method</code>调用开始了，同理<code>old</code>指向的是上次定义的<code>obj[name]</code>,同样还是闭包，还得留着。</li><li>到这里，内存中存在着三个<code>obj[name]</code>，因为三次<code>method</code>的内存都没有被删除，这是不是实现了三个函数共存，同时还可以用<code>old</code>将他们联系起来岂不是很妙。</li><li>我们在<code>people.find()</code>的时候，就会最先调用最后一次调用的<code>method</code>时定义的<code>function</code>，如果参数个数相同也就是<code>arguments.length === fnc.length</code>那么执行就好了，也就无需找其他的函数了，如果不同，那就得用到<code>old</code>了最后<code>return old.apply(this, arguments);</code>。<code>old</code>指向的是上一次<code>method</code>调用时候定义的函数，所以我们就去上一次找，如果找到了，继续执行<code>arguments.length === fnv.length</code>如果找不到，再次调用<code>old</code>往上面找，只要你有定义就能找的到。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>运用闭包的原理使得三个函数共存于内存中，<code>old</code>相当于一个指针，指向上一次定义的<code>function</code>，每次调用的时候，决定是否需要寻找。</p><p>最后执行的结果</p><p><img src="http://p7jj1bbaq.bkt.clouddn.com/1648d5ff924ed332.png" alt="console"></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近期遇到的BUG汇总【1】</title>
      <link href="/%E8%BF%91%E6%9C%9F%E9%81%87%E5%88%B0%E7%9A%84BUG%E6%B1%87%E6%80%BB%E3%80%901%E3%80%91/"/>
      <url>/%E8%BF%91%E6%9C%9F%E9%81%87%E5%88%B0%E7%9A%84BUG%E6%B1%87%E6%80%BB%E3%80%901%E3%80%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近一段时间一直忙于公司项目的跟进，没能继续博客的更新但是在项目中遇到了一些自己没怎么遇见或者说比较棘手，也许说是比较奇葩的几个BUG。</p></blockquote><hr><h2 id="pointer-events-css属性"><a href="#pointer-events-css属性" class="headerlink" title="pointer-events css属性"></a>pointer-events css属性</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">pointer-events</span>: <span class="selector-tag">none</span>;</span><br></pre></td></tr></table></figure><p>起初的实现是在写一个hover出的a<link>标签的时候点击实现一个跳转，但是在我手抖写css的时候手抖写出了以前没有遇到过的属性<code>pointer-events</code>。起初的跳转失败以为是js时间绑定，各种疯狂的寻找后发现问题并不是出现在这里。然后思路跳回css从<code>z-index</code>页面层级上面着手，层级关系显示父级的<code>position</code>为absolute,子元素也没有受到父级的遮挡，但是点击以后没有能够执行。万般无奈的只能复查css属性，结果查到了这个<code>none</code>值。</p><h3 id="了解pointer-events"><a href="#了解pointer-events" class="headerlink" title="了解pointer-events"></a>了解pointer-events</h3><p>真的说完全没有见过这个属性还是不对的，对于这个属性还是有着一面之缘，在一些注重节假日氛围烘托的网站是有一些跟随节日主题的特效生成，比如什么圣诞节的雪花飘落，闪烁的星空等等。而这些粒子效果有的实现是用<code>flash</code>、<code>canvas</code>，但是也有纯<code>html、css</code>写成的效果，这里面一般在最外层的效果层级都会加上这个属性，类似于点击穿透不会影响正常层级页面的事件委托，click、mouseover等所有事件会穿透它到达它的下一级元素。从而达到只是效果呈现的目的。算得上是一个比较黑科技的武器了。</p><p>适用的场景除了上面所说的还比如有一些类似数据可视化的在一些操作用的<code>action</code>的地方全局<code>pointer-events: none</code>然后在想要有事件捕获的子元素加上<code>pointer-events: auto</code>。这样就不会影响数据展示层也能实现面板自由使用。</p><p>兼容性</p><p><img src="http://p7jj1bbaq.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_15259213366850.png" alt="兼容性"></p><p>然后这里还有一篇张鑫旭大佬在13年关于这个属性引出的一篇文章的疯狂Diss,可以看看程序猿的众生百态<a href="http://www.zhangxinxu.com/wordpress/2014/01/pointer-events-none-avoiding-unnecessary-paints/" target="_blank" rel="noopener">点位</a></p><h2 id="vue-事件绑定-fn-里括号的书写"><a href="#vue-事件绑定-fn-里括号的书写" class="headerlink" title="vue 事件绑定 fn()里括号的书写"></a>vue 事件绑定 fn()里括号的书写</h2><p>有这样一个点击搜索按钮，获取分页的表格数据回来的代码。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">"success"</span> @<span class="attr">click</span>=<span class="string">"fetchData()"</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> fetchData(page) &#123;</span><br><span class="line">  page = page || <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(page);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.list = <span class="keyword">await</span> <span class="keyword">this</span>.fetchPage(&#123;</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">    url: <span class="string">`<span class="subst">$&#123;base&#125;</span>/`</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      where: <span class="keyword">this</span>.filters,</span><br><span class="line">      page,</span><br><span class="line">      sort: <span class="keyword">this</span>.sort,</span><br><span class="line">    &#125;,</span><br><span class="line">    loading: <span class="string">'loading'</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果绑定的获取事件丢失括号获取到的<code>page</code>属性为</p><p><img src="http://p7jj1bbaq.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_15241931435010.png" alt="page属性"></p><p>正确加了括号后取到的</p><p><img src="http://p7jj1bbaq.bkt.clouddn.com/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_15241931410.png" alt="page值"></p><h2 id="微信开发中引起的跨域问题"><a href="#微信开发中引起的跨域问题" class="headerlink" title="微信开发中引起的跨域问题"></a>微信开发中引起的跨域问题</h2><p>在做微信扫码登录的时候用到了微信的api,直接在前端用AJAX请求会百分百提示跨域，那是不可取的，非要上前端请求去拿<code>JSONP</code>解决跨域，对于微信来说这种非官方的协议是不安全的，会报错导致无返回正确结果。然后就是本地环境<code>localhost</code>请求也是无法正确请求的，微信不能以<code>ip</code>形式请求，所以老老实实测试环境上动刀了。</p>]]></content>
      
      
      <categories>
          
          <category> BUG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> bug </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodejs实现邮箱注册验证激活</title>
      <link href="/nodejs%E5%AE%9E%E7%8E%B0%E9%82%AE%E7%AE%B1%E6%B3%A8%E5%86%8C%E9%AA%8C%E8%AF%81%E6%BF%80%E6%B4%BB/"/>
      <url>/nodejs%E5%AE%9E%E7%8E%B0%E9%82%AE%E7%AE%B1%E6%B3%A8%E5%86%8C%E9%AA%8C%E8%AF%81%E6%BF%80%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这两天要实现一个通过邮箱注册然后自动发送激活邮件给用户，然后用户进入自己邮箱点击邮件中的链接实现激活邮箱的需求。算是一个比较常见简单的需求，但是是第一次做，还是值得记录一下。以便于以后的总结。</p><hr><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>发送激活邮件，当然第一件事就是得有邮箱了，作为公司业务的话应该就是有自己专门的企业邮箱。如果没有没关系，自己注册一个啦(推荐腾讯的企业邮箱或者网易的126邮箱，都是免费、稳定、简洁的邮箱)，之后就去邮箱的设置界面设置。找到<code>设置栏</code>，一般选择<code>POP3/SMTP/IMAP</code>，开启<code>POP3/SMTP/IMAP</code>服务，最后在设置一下授权码就算完成第一步了。</p></blockquote><ol><li><p>首先数据库里面需要有三个字段。<code>state</code>(0:未激活，1:已激活)、<code>code</code>(激活码 uuid(20))、<code>effective_time</code>(激活码有效期(生成链接24小时内))</p></li><li><p>用户填写邮箱，填写密码重复密码后提交注册，后台接受数据，插入用户这条数据成功。<code>state</code>默认为0未激活，并生成一个<code>code</code>（最好是通过传过来的邮箱、密码这些数据融合后加密生成），同时存入数据库。</p></li><li><p>发送邮件到用户注册用的邮箱，并且提示用户登录刚刚的邮箱验证激活。邮件正文中带一个<code>email</code>（这里最好是用户的<code>uid</code>比较合适）和<code>code</code>两个参数的URL供用户点击验证。</p></li><li><p>用户登录自己的邮箱，读取我们发送的验证邮件，用户通过点击链接或者复制地址访问的方式来到我们的业务邮箱验证页面。然后得到<code>url</code>里的两个参数，查阅数据库验证是否存在用户或验证码，不存在则为错误的验证链接地址。如存在则验证对应的<code>有效期</code>是够小于当前时间，没过期则最后验证两个字段是否一一对应，全部通过则算激活成功。设置<code>state</code>字段为1。跳转至登录页面，否则验证失败跳转至验证失败页面。</p></li></ol><h3 id="先来认识一下nodemailer"><a href="#先来认识一下nodemailer" class="headerlink" title="先来认识一下nodemailer"></a>先来认识一下<code>nodemailer</code></h3><ul><li>zero dependencies /零依赖</li><li>Heavy focus on security /重安全</li><li>Unicode support /支持任何字符 甚至 emoji 👻</li><li>Windows support windows /快速install</li><li>Use HTML content, as well as plain text alternative 支持纯文本更甚至html语言</li><li>Add Attachments to messages /可附件/</li><li>Embedded image attachments for HTML content /嵌入img至你的html中</li><li>Secure email delivery using TLS/STARTTLS /安全邮件</li><li>Different transport methods in addition to the built-in SMTP support /不同传输方式</li><li>Sign messages with DKIM /用DKIM签名</li><li>Custom Plugin support for manipulating messages /自定义插件操纵消息</li><li>Sane OAuth2 authentication /OAuth2认证</li><li>Proxies for SMTP connections /代理</li><li>ES6 code – no more unintentional memory leaks, due to hoisted var’s /ES6</li><li>Autogenerated email test accounts from Ethereal.email</li></ul><blockquote><p>node版本v6.0+</p></blockquote><p>总之就是<code>nodemailer</code>这个库很牛逼，先安装具体看<a href="https://nodemailer.com/about/" target="_blank" rel="noopener">官网</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install nodemailer --save</span><br></pre></td></tr></table></figure><p>来看具体的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">const</span> nodemailer = <span class="built_in">require</span>(<span class="string">'nodemailer'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接入的是腾讯企业邮箱这里分别填入你设置的账号和pass</span></span><br><span class="line"><span class="keyword">let</span> transporter = nodemailer.createTransport(&#123;</span><br><span class="line">    service: <span class="string">'QQex'</span>,</span><br><span class="line">    auth: &#123;</span><br><span class="line">        user: <span class="string">''</span>,<span class="comment">// 邮箱</span></span><br><span class="line">        pass: <span class="string">''</span><span class="comment">// pass</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sendRegisterCodeUrl = exports.sendRegisterCodeUrl = <span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;email, code&#125; = item;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'get email~ code~'</span>,email, code);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> text = <span class="string">`尊敬的<span class="subst">$&#123;email&#125;</span>，您好, </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    感谢您参加比***活动。 </span></span><br><span class="line"><span class="string">    请点击以下链接进行邮箱验证，以便开始您的***： </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    https://example.com?mail=<span class="subst">$&#123;email&#125;</span>&amp;code=<span class="subst">$&#123;code&#125;</span> </span></span><br><span class="line"><span class="string">    如果您并未参加***活动，可能是其他用户误输入了您的邮箱地址。请忽略此邮件，或者联系我们。 </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    ***** - ***</span></span><br><span class="line"><span class="string">    广东省广州市番禺区********************** / 020-******* `</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> mailOptions = &#123;</span><br><span class="line">      subject: <span class="string">'邮箱激活通知'</span>, <span class="comment">// Subject line</span></span><br><span class="line">      <span class="keyword">from</span>: <span class="string">'"发件方大名" &lt;example@abc.cc&gt;'</span>, <span class="comment">// 可设置发件人主题</span></span><br><span class="line">      to: <span class="string">`<span class="subst">$&#123;email&#125;</span>`</span>, <span class="comment">//收件人的邮箱地址</span></span><br><span class="line">      text: text, <span class="comment">// 纯文本形式</span></span><br><span class="line">      html: getRegisterHtml(email, code) <span class="comment">// html 形式（可设置按钮，邮件内容样式）</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调取发送邮件方法</span></span><br><span class="line">    transporter.sendMail(mailOptions, (error, info) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'发送邮件出错：'</span>, error);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">'Message %s sent: %s'</span>, info.messageId, info.response);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'发送邮件出错：'</span>,e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是具体的HTML格式的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 传入需要的参数</span></span><br><span class="line"><span class="comment">* 生成你想要呈现的文件形式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRegisterHtml</span>(<span class="params">email, code</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> html = <span class="string">`&lt;div&gt;这里是HTML~&lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">  <span class="keyword">return</span> html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>到这里基本的业务发送邮件的地方就算是简答实现了，但是严格上来说还是有很多值得改进的地方，比如在验证生成<code>code</code>的地方，应该是用用户的相关联信息邮箱来生成加密后的code码而不是直接的生成，同样的在验证激活地址的时候应该传入的是用户的<code>uid</code>而不是<code>email</code>地址，虽然觉得没什么毛病，但是还是感觉怪怪的说不上严禁。再则就是<code>nodemailer</code>的功能的确很强大，我只是使用到了一丁点的皮毛，比如邮件附件的添加、邮箱日历事件接入、List headers等等都没有用上。值得我去更加深入的运用它，以至在今后的需求实现中得以得心应手~</p>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> nodemailer </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEXO博客加上来必力（livere）评论</title>
      <link href="/HEXO%E5%8D%9A%E5%AE%A2%E5%8A%A0%E4%B8%8A%E6%9D%A5%E5%BF%85%E5%8A%9B%EF%BC%88livere%EF%BC%89%E8%AF%84%E8%AE%BA/"/>
      <url>/HEXO%E5%8D%9A%E5%AE%A2%E5%8A%A0%E4%B8%8A%E6%9D%A5%E5%BF%85%E5%8A%9B%EF%BC%88livere%EF%BC%89%E8%AF%84%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="接入合适的评论"><a href="#接入合适的评论" class="headerlink" title="接入合适的评论"></a>接入合适的评论</h2><hr><p>目前市面上大家用的比较多的几个评论接入有如下几个：</p><ul><li>HyperComments <a href="https://www.hypercomments.com" target="_blank" rel="noopener">https://www.hypercomments.com</a> 一款来自毛子的系统，考虑到战斗民族的战斗性情，我还是选择了放弃（主要还是主题没接入(；´д｀)ゞ）</li><li>畅言 <a href="http://changyan.kuaizhan.com" target="_blank" rel="noopener">http://changyan.kuaizhan.com </a> 在国内大小网站都有接入，对于国内用户有不错的体验，但是丑丑的界面有点不能接受，但是这个需要有备案号，虽然我有但是我注册了居然还各种给我审核，丑拒~</li><li>Gitment <a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">https://github.com/imsun/gitment </a> 之前大家说最好不怕和谐的方案就是直接issue的方式提交到github上不为一个不错的方案。gitman就是解决了这样一个东东，但是比较差的是貌似只能是github登录评论？岂不是不友好，弃之~</li><li>Gitalk <a href="https://gitalk.github.io/" target="_blank" rel="noopener">https://gitalk.github.io/</a> 一个基于 Github Issue 和 Preact 开发的评论插件,比较好的是支持Markdown语法，挺实用的一个功能吧，舍弃的原因同上。</li><li>Disqus <a href="https://disqus.com" target="_blank" rel="noopener">https://disqus.com</a> 做得很好的一款，支持很多登录，而且我对他的界面UI真的很心水，很符合当下的这个主题风格，非常的整洁舒适的风格。但是就是被墙了、被墙了、被墙了（重要的事情说三遍）。无奈放弃了（后面会说到）</li><li>来必力 <a href="https://livere.com" target="_blank" rel="noopener">https://livere.com</a> 韩国思密达出品，界面中规中矩。能够接受的风格，重要的是没被墙，而且后台管理挺不错，可以邮箱通知提交的评论。支持三种语言中、英、汉语。而且根据语言环境支持合适的登录方式。一溜的国内大厂的登录方式对于大家的使用友好感MAX百分百。</li><li>友言 <a href="http://www.uyan.cc" target="_blank" rel="noopener">http://www.uyan.cc</a> 国内出品，没有具体了解过，风格看起来挺清爽的样子，有时间可以尝试接入一下。</li><li>多说 已经下线，记得烧纸。</li><li>网易云 已经下线，记得烧纸。</li></ul><h2 id="起初采坑"><a href="#起初采坑" class="headerlink" title="起初采坑"></a>起初采坑</h2><p>最开始的时候接入的是我最心水风格的<code>Disqus</code>，清爽的风格呈现，友好的交互效果，通俗易懂的接入文档。。。（好了，我编不下去了，其实就是因为主题默认的第一个社会化评论就是它。。。）</p><h3 id="起初的一切都是那么的完美"><a href="#起初的一切都是那么的完美" class="headerlink" title="起初的一切都是那么的完美"></a>起初的一切都是那么的完美</h3><p>可以看见更多的支持的是国外使用率较高的、或者是存在的（此处404）登录方式。实在是可惜。<br><img src="http://p7jj1bbaq.bkt.clouddn.com/0.png" alt="未登录界面"></p><p><img src="http://p7jj1bbaq.bkt.clouddn.com/1.png" alt="登录后无评论界面"></p><p><img src="http://p7jj1bbaq.bkt.clouddn.com/4.png" alt="登录后有评论界面"></p><p>只是登录方式的不完备性其实还能都接受，然而这一切都是在我打开了代理的情况下呈现的，当我关闭代理后，我猛然发现–我的评论模块去哪儿了？ 再去一百度结果才发现，被赤裸裸的墙了。太可惜了，对于我这样的没有梯子不能访问评论的依赖我是不能忍得，忍痛割爱了~</p><h3 id="尝试其他"><a href="#尝试其他" class="headerlink" title="尝试其他"></a>尝试其他</h3><blockquote><p>期间我也尝试接入了其他的一些评论接入，比如Gitalk和畅言。但是最后都还是舍弃了，不过他们都有各自的优点，可以先注册好，以便于以后这个挂了之后有一个备用的方案，一定要有plan B ~。</p></blockquote><h2 id="来必力"><a href="#来必力" class="headerlink" title="来必力"></a>来必力</h2><p>1.第一步当然是打开官网先注册了。<a href="https://livere.com" target="_blank" rel="noopener">https://livere.com</a>,按照</p><p><img src="http://p7jj1bbaq.bkt.clouddn.com/5.png" alt="注册填写"></p><p>邮箱注册，限制性可以说是基本没有了。貌似官网是需要科学上网的，昵称就是你回复的昵称啦。是可以随时修改的。</p><p>2.选择你想要的版本</p><p>好吧其实，我只会选City版（免费…），其他的也可以能享受更好的定制服务，土豪随意~</p><p><img src="http://p7jj1bbaq.bkt.clouddn.com/6.png" alt="选择版本"></p><p>3.拿到你无与伦比、高贵奢华的uid</p><p><img src="http://p7jj1bbaq.bkt.clouddn.com/3.png" alt="获取uid"></p><p>4.将你的uid正确的放到你的hexo项目下</p><p>不同的主题可能设置的方式有所区别。以下是我收集到的几个流行主题的设置方式：</p><h3 id="在Next中接入来必力配置如下："><a href="#在Next中接入来必力配置如下：" class="headerlink" title="在Next中接入来必力配置如下："></a>在Next中接入来必力配置如下：</h3><ul><li><p>首先在 _config.yml 文件中添加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Support for LiveRe comments system.</span><br><span class="line"># You can get your uid from https://livere.com/insight/myCode (General web site)</span><br><span class="line">livere_uid: your uid</span><br></pre></td></tr></table></figure></li><li><p>在 layout/_scripts/third-party/comments/ 目录中添加 livere.swig，文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125;</span><br><span class="line">  &#123;% if theme.livere_uid %&#125;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">      (function(d, s) &#123;</span><br><span class="line">        var j, e = d.getElementsByTagName(s)[0];</span><br><span class="line">        if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125;</span><br><span class="line">        j = d.createElement(s);</span><br><span class="line">        j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;;</span><br><span class="line">        j.async = true;</span><br><span class="line">        e.parentNode.insertBefore(j, e);</span><br><span class="line">      &#125;)(document, &apos;script&apos;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li></ul><p>优先使用其他评论插件，如果其他评论插件没有开启，且 LiveRe 评论插件配置开启了，则使用 LiveRe。其中脚本代码为上一步管理页面中获取到的。 </p><ul><li><p>在 layout/_scripts/third-party/comments.swig 文件中追加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include &apos;./comments/livere.swig&apos; %&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后，在 layout/_partials/comments.swig 文件中条件最后追加 LiveRe 插件是否引用的判断逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% elseif theme.livere_uid %&#125;</span><br><span class="line">      &lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;&#123;&#123; theme.livere_uid &#125;&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="在主题yilia中接入如下："><a href="#在主题yilia中接入如下：" class="headerlink" title="在主题yilia中接入如下："></a>在主题yilia中接入如下：</h3><ul><li>找到并打开yilia目录下的新建文件livere.ejs</li></ul><p>具体目录 <code>/yilia/layout/_partial/post</code> 下</p><ul><li>将一般网站下的代码复制粘贴进去</li></ul><p>代码实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 来必力City版安装代码 --&gt;</span><br><span class="line">&lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;你的uid&quot;&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   (function(d, s) &#123;</span><br><span class="line">       var j, e = d.getElementsByTagName(s)[0];</span><br><span class="line"></span><br><span class="line">       if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125;</span><br><span class="line"></span><br><span class="line">       j = d.createElement(s);</span><br><span class="line">       j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;;</span><br><span class="line">       j.async = true;</span><br><span class="line"></span><br><span class="line">       e.parentNode.insertBefore(j, e);</span><br><span class="line">   &#125;)(document, &apos;script&apos;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- City版安装代码已完成 --&gt;</span><br></pre></td></tr></table></figure></p><ul><li>打开yilia的文件夹里的_config.yml并粘贴一下代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 来必力</span><br><span class="line">livere: 你的uid</span><br></pre></td></tr></table></figure></li></ul><h3 id="在主题melody下面接入："><a href="#在主题melody下面接入：" class="headerlink" title="在主题melody下面接入："></a>在主题melody下面接入：</h3><p>也就是我现在使用的主题，其实<a href>官方文档</a><a href="https://molunerfinn.com/hexo-theme-melody-doc/#/third-party-support?id=laibili已经讲的很明白，很简答了。" target="_blank" rel="noopener">https://molunerfinn.com/hexo-theme-melody-doc/#/third-party-support?id=laibili已经讲的很明白，很简答了。</a><br>Set the melody.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">laibili:</span><br><span class="line">  enable: true # or false</span><br><span class="line">  uid: your laibili uid</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>此处没有小结。</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的前端面试题小结【1】</title>
      <link href="/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%B0%8F%E7%BB%93%E3%80%901%E3%80%91/"/>
      <url>/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%B0%8F%E7%BB%93%E3%80%901%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在无尽的javascript海洋里面，往往有一些容易混淆的东西存在。他们的出现总是能够扰乱我们的，咦~ 这个是什么，那个又是什么。一头懵逼之前不如先好好的理解透彻以便掌握他们，他们就是javascript中的魔鬼。</p><h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call | apply | bind"></a>call | apply | bind</h2><p>在js中最容易让人犯错的就是this了。当我们遇到一些复杂的场景的时候就会发现this变得如此可怕，使用的时候就会莫名其妙的出现很多意想不到的奇葩情况出现。因此，大多数的时候为了防止错误，我们会手动的指定一下上下文的环境，来修正this的指向。比如说<code>let _self = this</code> 或者 <code>let that = this</code>。正确的调用者才能不容易出错。</p><h3 id="先来看一个容易掉坑里的面试题"><a href="#先来看一个容易掉坑里的面试题" class="headerlink" title="先来看一个容易掉坑里的面试题"></a>先来看一个容易掉坑里的面试题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  name : <span class="string">'wds'</span>,</span><br><span class="line">  sayName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = a.sayName;</span><br><span class="line">b();  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>按照起初我们常规的思路去思考，a的sayName方法赋值给了b，查看a的name值是什么。打印出的应该是<code>wds</code>，然而输出的结果却是<code>undefined</code>。异常结果的原因就是在调用函数b的时候，sayName中的<code>this</code>已经不是指向的是对象a了。而是指向的是全局对象<code>window</code>，然而我们的<code>window</code>下面是没有name这一属性的，于是乎就打印出了<code>undefined</code>。</p><p>回归正题，我们尝试着用<code>call | apply | bind</code>三兄弟来解决这个问题</p><h3 id="使用call"><a href="#使用call" class="headerlink" title="使用call"></a>使用call</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = a.sayName;</span><br><span class="line">b.call(a); <span class="comment">// wds</span></span><br></pre></td></tr></table></figure><h3 id="使用apply"><a href="#使用apply" class="headerlink" title="使用apply"></a>使用apply</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = a.sayName;</span><br><span class="line">b.apply(a); <span class="comment">//wds</span></span><br></pre></td></tr></table></figure><h3 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a>call和apply的区别</h3><p>call和apply的主区别就是在后续参数的接入不同，通过改造上面的例子来观察具体的不同。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  name : <span class="string">'wds'</span>,</span><br><span class="line">  sayName : <span class="function"><span class="keyword">function</span>(<span class="params">firstname, lastname</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;firstname&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> <span class="subst">$&#123;lastname&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = a.sayName;</span><br><span class="line">b.call(a,<span class="string">'first'</span>,<span class="string">'last'</span>);  <span class="comment">// first wds last</span></span><br><span class="line">b.apply(a,<span class="string">'first'</span>,<span class="string">'last'</span>);  <span class="comment">// first wds last</span></span><br></pre></td></tr></table></figure></p><h3 id="使用bind"><a href="#使用bind" class="headerlink" title="使用bind"></a>使用bind</h3><p>同样的使用<code>bind</code>来改变this的指向你会发现，并没有打印。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = a.sayName</span><br><span class="line">b.bind(a);</span><br></pre></td></tr></table></figure><p><code>bind</code>在绑定之后并不会立即执行函数，需要你手动执行，这样的好处就是你可以延缓b函数执行的时间，在确定想要执行的时候再调用他。其次，<code>bind</code>是同样支持其他参数的传入的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = a.sayName</span><br><span class="line">b.bind(a,<span class="string">'abc'</span>,<span class="string">'123'</span>)(); <span class="comment">//</span></span><br></pre></td></tr></table></figure><h2 id="splice-slice-split"><a href="#splice-slice-split" class="headerlink" title="splice | slice | split"></a>splice | slice | split</h2><p>光是第一眼看见这三姐妹，头就很快很晕了。最好的方法从简入深先了解单词的语义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">splice  拼接</span><br><span class="line">slice   片、切片</span><br><span class="line">split   分裂、裂开</span><br></pre></td></tr></table></figure><p>根据他的语义解释我们就能了解到其API大致的意思了。</p><ul><li>splice  其意为拼接，他的意思就是将一个数组分隔开来，再按照指定的方式来重新拼接到一起。</li><li>slice   意为切片，可以用它来在一个数组或是字符串中得到我们想要的那一部分。</li><li>split   意为分裂，可以将一个字符串分裂成一个我们想要的数组。</li></ul><h3 id="splice的使用"><a href="#splice的使用" class="headerlink" title="splice的使用"></a>splice的使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">a.splice(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// [1,4,4,4,5]</span></span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" target="_blank" rel="noopener">MDN-splice</a> array.splice(start, deleteCount, item1, item2, …) 第一个参数<code>start</code>为删除的起始元素序号，第二个参数<code>deleteCount</code>为删除的数量，后面的<code>item</code>则为插入的内容。</p><blockquote><p>注意：<code>splice</code>方法会修改原数组，返回修改后的数组。</p></blockquote><h3 id="使用slice"><a href="#使用slice" class="headerlink" title="使用slice"></a>使用slice</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> b = <span class="string">'12345'</span></span><br><span class="line">a.slice(<span class="number">1</span>,<span class="number">3</span>);  <span class="comment">//[2,3]</span></span><br><span class="line">a.slice(<span class="number">1</span>);  <span class="comment">//[2,3,4,5]</span></span><br><span class="line">a.slice(<span class="number">2</span>,<span class="number">-1</span>)  <span class="comment">//[3,4]</span></span><br><span class="line">b.slice(<span class="number">1</span>,<span class="number">2</span>);  <span class="comment">//'2'</span></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//[1,2,3,4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">//'12345'</span></span><br></pre></td></tr></table></figure><ul><li>slice数组既可以用于数组也可以用于字符串</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/slice" target="_blank" rel="noopener">MDN-slice</a> str.slice(beginSlice[, endSlice]) 接受最多两个参数,第一个参数代表的序列号必须小于第二个参数，第二个参数为切片的终止位置，第二个参数省略时默认截取到数据末尾，参数为负数时，将反向查找匹配项。</li></ul><blockquote><p>注意：<code>slice</code>方法不会修改原始数组，返回的是被切片节选的片段。</p></blockquote><h3 id="使用split"><a href="#使用split" class="headerlink" title="使用split"></a>使用split</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'123456'</span>;</span><br><span class="line">a.split(<span class="string">''</span>);  <span class="comment">//['1','2','3','4','5','6']</span></span><br><span class="line">a.split(<span class="string">''</span>,<span class="number">3</span>);  <span class="comment">//['1','2','3']</span></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">//'123456'</span></span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split" target="_blank" rel="noopener">MDN-split</a> str.split([separator[, limit]]) 方法可接受两个参数，第一个参数为分割符，用于指定字符串的分割规则，第二个参数为返回数组的最大长度，返回的输出长度不会大于这个参数。</p><blockquote><p>注意: <code>split</code>不会修改原始字符串，返回值为新数组。</p></blockquote><h2 id="map-forEach-reduce-filter-every-some"><a href="#map-forEach-reduce-filter-every-some" class="headerlink" title="map | forEach | reduce | filter | every | some"></a>map | forEach | reduce | filter | every | some</h2><p>这六个方法均为操作数组的常用API，均为Array.prototype的本地方法。所以一切数组都可以使用这些方法去遍历操作数组的每一项。来看看他们具体的功能。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [</span><br><span class="line">  &#123;<span class="string">'name'</span>: <span class="string">'tim'</span>&#125;,</span><br><span class="line">  &#123;<span class="string">'name'</span>: <span class="string">'cook'</span>&#125;,</span><br><span class="line">  &#123;<span class="string">'name'</span>: <span class="string">'adam'</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newArr = arr.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (&#123;</span><br><span class="line">    <span class="string">'name'</span>: item.name,</span><br><span class="line">    <span class="string">'index'</span>: index</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [&#123;'name':'tim'&#125;,&#123;'name':'cook'&#125;,&#123;'name':'adam'&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// [&#123;'name': 'tim', 'index': 0&#125;,&#123;'name': 'cook', 'index': 1&#125;,&#123;'name': 'adam', 'index': 2&#125;]</span></span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener">MDN-map</a> map(fn(item, index)) 方法接受一个函数作为参数，这个函数有两个参数，分别是每一项的数组，以及该元素的下标。</p><blockquote><p>注意: <code>map</code>返回一个新数组，如果在操作中没有return返回值，默认返回一个值为undefined的数组。<br>默认返回：[undefined, undefined, undefined]</p></blockquote><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="function">(<span class="params">item, index</span>)=&gt;</span>&#123;</span><br><span class="line">  item.old = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">delete</span> item.name;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [&#123;'old': true&#125;,&#123;'old': true&#125;,&#123;'old': true&#125;]</span></span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="noopener">MDN-forEach</a> forEach(callback(item, index, array){}, this) 方法接受一个函数作为参数，这个函数有三个参数，第一个是当前操作的元素，第二个是当前操作元素的索引。array则是正在操作的数组。</p><blockquote><p>注意: <code>forEach</code>直接操作原数组。</p></blockquote><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>简单的用例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> res = arr.reduce(<span class="function">(<span class="params">curr, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> curr + next</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>稍复杂用例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res1 = arr.reduce(<span class="function">(<span class="params">curr, next, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'comtent'</span>, curr, next, index, arr)</span><br><span class="line">  <span class="keyword">return</span> curr + next</span><br><span class="line">&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res1);</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">初始值(curr)</th><th style="text-align:center">当前元素(next)</th><th style="text-align:center">当前元素索引(index)</th><th style="text-align:center">元素数组(arr)</th><th style="text-align:center">函数初始值</th></tr></thead><tbody><tr><td style="text-align:center">10</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">[1,2,3,4,5]</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">[1,2,3,4,5]</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">[1,2,3,4,5]</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">4</td><td style="text-align:center">3</td><td style="text-align:center">[1,2,3,4,5]</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">5</td><td style="text-align:center">4</td><td style="text-align:center">[1,2,3,4,5]</td><td style="text-align:center">10</td></tr></tbody></table><p><code>reduce</code>方法用于对数组的累计化操作，常常用于数组的求和。接受两个参数，一个是为操作函数，另外一个是函数的初始值。对于数组的操作不会修改原始值。</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = arr.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'data:'</span>, item, index);</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">3</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">//[4, 5]</span></span><br></pre></td></tr></table></figure><p><code>filter</code>方法用于过滤数组的每一项。筛选出符合条件的元素，并且组成一个新的数组返回。</p><blockquote><p>以上的<code>reduce</code>只是非常非常浅显的大致了解了他的使用，需要更加详细的理解可以去看这一篇文章 <a href="https://segmentfault.com/a/1190000010731933" target="_blank" rel="noopener">JS进阶篇–JS数组reduce()方法详解及高级技巧</a></p></blockquote><h3 id="every"><a href="#every" class="headerlink" title="every"></a>every</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = arr.every(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">3</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><code>every</code>方法将每一个元素进行条件检查，全部符合返回ture，否则返回为false。</p><h3 id="some"><a href="#some" class="headerlink" title="some"></a>some</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res = arr.some(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">3</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><code>some</code>方法同<code>every</code>类似，只不过是或判断。将每一个元素进行条件检查，有符合条件的就返回ture，否则返回为false。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>算得上是第一次真正的在写东西了，第一次写才发现自己的文笔是多么的浅显。看来还是得多写多练习呀。学习这件事儿不能只是看别人的，还是得自己亲自动手去码、去理解才行呐。大多数的内容现在还都只是从网上的笔记里面拿过来的，更多的只能算是笔记誊抄，没有太多自己的东西。不过总算是写起来了，万事开头难不是吗？</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

---
title: 有趣的前端面试题小结【1】
date: 2018-04-10 15:02:05
top_img: 180410.jpg
tags:
  - 前端
  - 面试
  - javascript
categories:
    面试题  
---



## 前言
在无尽的javascript海洋里面，往往有一些容易混淆的东西存在。他们的出现总是能够扰乱我们的，咦~ 这个是什么，那个又是什么。一头懵逼之前不如先好好的理解透彻以便掌握他们，他们就是javascript中的魔鬼。

## call | apply | bind
在js中最容易让人犯错的就是this了。当我们遇到一些复杂的场景的时候就会发现this变得如此可怕，使用的时候就会莫名其妙的出现很多意想不到的奇葩情况出现。因此，大多数的时候为了防止错误，我们会手动的指定一下上下文的环境，来修正this的指向。比如说`let _self = this` 或者 `let that = this`。正确的调用者才能不容易出错。

### 先来看一个容易掉坑里的面试题

``` js
let a = {
  name : 'wds',
  sayName : function() {
    console.log(this.name);
  }
}

let b = a.sayName;
b();  // undefined
```

按照起初我们常规的思路去思考，a的sayName方法赋值给了b，查看a的name值是什么。打印出的应该是`wds`，然而输出的结果却是`undefined`。异常结果的原因就是在调用函数b的时候，sayName中的`this`已经不是指向的是对象a了。而是指向的是全局对象`window`，然而我们的`window`下面是没有name这一属性的，于是乎就打印出了`undefined`。

回归正题，我们尝试着用`call | apply | bind`三兄弟来解决这个问题

### 使用call

``` js
let b = a.sayName;
b.call(a); // wds
```

### 使用apply

``` js
let b = a.sayName;
b.apply(a); //wds 
```

### call和apply的区别
call和apply的主区别就是在后续参数的接入不同，通过改造上面的例子来观察具体的不同。
``` js
let a = {
  name : 'wds',
  sayName : function(firstname, lastname) {
    console.log(`${firstname} ${this.name} ${lastname}`);
  }
}

let b = a.sayName;
b.call(a,'first','last');  // first wds last
b.apply(a,'first','last');  // first wds last
```

### 使用bind

同样的使用`bind`来改变this的指向你会发现，并没有打印。

``` js
let b = a.sayName
b.bind(a);
```

`bind`在绑定之后并不会立即执行函数，需要你手动执行，这样的好处就是你可以延缓b函数执行的时间，在确定想要执行的时候再调用他。其次，`bind`是同样支持其他参数的传入的。

``` js
let b = a.sayName
b.bind(a,'abc','123')(); // 
```
## splice | slice | split

光是第一眼看见这三姐妹，头就很快很晕了。最好的方法从简入深先了解单词的语义。

```
splice  拼接
slice   片、切片
split   分裂、裂开
```

根据他的语义解释我们就能了解到其API大致的意思了。
* splice  其意为拼接，他的意思就是将一个数组分隔开来，再按照指定的方式来重新拼接到一起。
* slice   意为切片，可以用它来在一个数组或是字符串中得到我们想要的那一部分。
* split   意为分裂，可以将一个字符串分裂成一个我们想要的数组。

### splice的使用

``` js
let a = [1,2,3,4,5]
a.splice(1,2,4,4)
console.log(a) // [1,4,4,4,5]
```

[MDN-splice](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) array.splice(start, deleteCount, item1, item2, ...) 第一个参数`start`为删除的起始元素序号，第二个参数`deleteCount`为删除的数量，后面的`item`则为插入的内容。

> 注意：`splice`方法会修改原数组，返回修改后的数组。

### 使用slice

``` js
  let a = [1,2,3,4,5]
  let b = '12345'
  a.slice(1,3);  //[2,3]
  a.slice(1);  //[2,3,4,5]
  a.slice(2,-1)  //[3,4]
  b.slice(1,2);  //'2'
  console.log(a);  //[1,2,3,4,5]
  console.log(b);  //'12345'
```
* slice数组既可以用于数组也可以用于字符串
* [MDN-slice](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/slice) str.slice(beginSlice[, endSlice]) 接受最多两个参数,第一个参数代表的序列号必须小于第二个参数，第二个参数为切片的终止位置，第二个参数省略时默认截取到数据末尾，参数为负数时，将反向查找匹配项。

> 注意：`slice`方法不会修改原始数组，返回的是被切片节选的片段。

### 使用split

``` js
  let a = '123456';
  a.split('');  //['1','2','3','4','5','6']
  a.split('',3);  //['1','2','3']
  console.log(a);  //'123456'
```
[MDN-split](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split) str.split([separator[, limit]]) 方法可接受两个参数，第一个参数为分割符，用于指定字符串的分割规则，第二个参数为返回数组的最大长度，返回的输出长度不会大于这个参数。

> 注意: `split`不会修改原始字符串，返回值为新数组。

## map | forEach | reduce | filter | every | some

这六个方法均为操作数组的常用API，均为Array.prototype的本地方法。所以一切数组都可以使用这些方法去遍历操作数组的每一项。来看看他们具体的功能。

### map

``` js
let arr = [
  {'name': 'tim'},
  {'name': 'cook'},
  {'name': 'adam'}
]

let newArr = arr.map((item, index) => {
  return ({
    'name': item.name,
    'index': index
  })
})

console.log(arr); // [{'name':'tim'},{'name':'cook'},{'name':'adam'}]

console.log(newArr); // [{'name': 'tim', 'index': 0},{'name': 'cook', 'index': 1},{'name': 'adam', 'index': 2}]
```

[MDN-map](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map) map(fn(item, index)) 方法接受一个函数作为参数，这个函数有两个参数，分别是每一项的数组，以及该元素的下标。

> 注意: `map`返回一个新数组，如果在操作中没有return返回值，默认返回一个值为undefined的数组。
> 默认返回：[undefined, undefined, undefined]

### forEach

``` js
arr.forEach((item, index)=>{
  item.old = true;
  delete item.name;
})

console.log(arr); // [{'old': true},{'old': true},{'old': true}]
```

[MDN-forEach](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) forEach(callback(item, index, array){}, this) 方法接受一个函数作为参数，这个函数有三个参数，第一个是当前操作的元素，第二个是当前操作元素的索引。array则是正在操作的数组。

> 注意: `forEach`直接操作原数组。

### reduce

简单的用例

``` js
let arr = [1, 2, 3, 4, 5];
let res = arr.reduce((curr, next) => {
  return curr + next
})
console.log(res); // 15
console.log(arr); // [1, 2, 3, 4, 5]
```

稍复杂用例

``` js
let res1 = arr.reduce((curr, next, index, arr) => {
  console.log('comtent', curr, next, index, arr)
  return curr + next
}, 10)
console.log(res1);
```

|初始值(curr)|当前元素(next)|当前元素索引(index)|元素数组(arr)|函数初始值|
|:---:|:---:|:---:|:---:|:---:|
|10|1|0|[1,2,3,4,5]|10|
|11|2|1|[1,2,3,4,5]|10|
|13|3|2|[1,2,3,4,5]|10|
|16|4|3|[1,2,3,4,5]|10|
|20|5|4|[1,2,3,4,5]|10|

`reduce`方法用于对数组的累计化操作，常常用于数组的求和。接受两个参数，一个是为操作函数，另外一个是函数的初始值。对于数组的操作不会修改原始值。

### filter
``` js
let res = arr.filter((item, index) => {
  console.log('data:', item, index);
  return item > 3;
})
console.log(res); //[4, 5]
```

`filter`方法用于过滤数组的每一项。筛选出符合条件的元素，并且组成一个新的数组返回。

> 以上的`reduce`只是非常非常浅显的大致了解了他的使用，需要更加详细的理解可以去看这一篇文章 [JS进阶篇--JS数组reduce()方法详解及高级技巧](https://segmentfault.com/a/1190000010731933)

### every

``` js
let res = arr.every((item, index) => {
  return item > 3;
})
console.log(res); //false
```

`every`方法将每一个元素进行条件检查，全部符合返回ture，否则返回为false。


### some

``` js
let res = arr.some((item, index) => {
  return item > 3;
})
console.log(res); //true
```

`some`方法同`every`类似，只不过是或判断。将每一个元素进行条件检查，有符合条件的就返回ture，否则返回为false。

## 小结

算得上是第一次真正的在写东西了，第一次写才发现自己的文笔是多么的浅显。看来还是得多写多练习呀。学习这件事儿不能只是看别人的，还是得自己亲自动手去码、去理解才行呐。大多数的内容现在还都只是从网上的笔记里面拿过来的，更多的只能算是笔记誊抄，没有太多自己的东西。不过总算是写起来了，万事开头难不是吗？